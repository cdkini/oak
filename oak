#!/usr/bin/env python3
from __future__ import annotations

from typing import Generator
import re
import contextlib
import datetime as dt
import os
import pathlib
import shutil
import subprocess
import sys


# Constants ================================================================
ROOT_ENV_VAR = "OAK_ROOT"
DEPENDENCIES = (
    "fd",  # Find files
    "rg",  # Search filesc
    "fzf",  # Fuzzy finder
    "bat",  # Preview files
    "nvim",  # Editor
)
GREEN = "\033[32m"
RED = "\033[31m"
BLUE = "\033[34m"
RESET = "\033[0m"  # Resets color to default


# Commands =================================================================
def add_cmd(root: pathlib.Path, args: list[str]) -> None:
    name = args[0] if args else f"tmp-{dt.datetime.now().strftime('%Y-%m-%d-%H-%M')}"
    tags = args[1:] if len(args) > 1 else []
    file_path = root / f"{name}.md"
    open_note(file_path, tags=tags)


def daily_cmd(root: pathlib.Path, args: list[str]) -> None:
    today = dt.datetime.now().strftime("%Y-%m-%d")
    file_path = root / f"{today}.md"
    open_note(file_path, tags=["daily"])


def delete_cmd(root: pathlib.Path, args: list[str]) -> None:
    query = args[0] if args else ""
    with cd(root):
        files = fzf_select(
            query=query,
            reload_cmd="reload:fd -e md --hidden --follow --exclude .git {q}",
            preview_cmd="bat {} --style=full --color=always",
        )
        for file in files:
            file.unlink()
            print(f"{BLUE}[DELETED]{RESET} {file.name}")


def grep_cmd(root: pathlib.Path, args: list[str]) -> None:
    query = args[0] if args else ""
    with cd(root):
        fzf_open(
            query=query,
            reload_cmd="reload:rg --column --color=always --smart-case {q} || :",
            preview_cmd="bat --style=full --color=always --highlight-line {2} {1}",
        )


def open_cmd(root: pathlib.Path, args: list[str]) -> None:
    query = args[0] if args else ""
    with cd(root):
        fzf_open(
            query=query,
            reload_cmd="reload:fd -e md --hidden --follow --exclude .git {q}",
            preview_cmd="bat {} --style=full --color=always",
        )


def list_cmd(root: pathlib.Path, args: list[str]) -> None:
    files = sorted(root.iterdir(), key=lambda f: f.stat().st_mtime, reverse=True)
    for file in files:
        if file.is_file() and file.suffix == ".md":
            frontmatter = YAMLFrontmatter.parse(file)
            print(f"{file.name:30} {frontmatter.created_at}   {frontmatter.tags}")


def help_cmd(root: pathlib.Path, args: list[str]) -> None:
    for cmd, (_, description) in COMMAND_MAP.items():
        print(f"{GREEN}{cmd:10}{RESET} {description}")


COMMAND_MAP = {
    "add": (add_cmd, "Add a new note"),
    "daily": (daily_cmd, "Add a new daily note"),
    "delete": (delete_cmd, "Delete note(s)"),
    "grep": (grep_cmd, "Search notes by content"),
    "open": (open_cmd, "Open notes by name"),
    "list": (list_cmd, "List files (in reverse chronological order)"),
    "help": (help_cmd, "Print this help message"),
}


# Utils ====================================================================
def error(message: str) -> None:
    print(f"{RED}[ERROR]{RESET} {message}")
    sys.exit(1)


def open_note(path: pathlib.Path, tags: list[str], content: str = "") -> None:
    if not path.exists():
        init_file(path=path, tags=tags, content=content)

    subprocess.run(["nvim", path])


class YAMLFrontmatter:
    def __init__(
        self, title: str, tags: list[str], created_at: dt.datetime = dt.datetime.now()
    ) -> None:
        self.title = title
        self.tags = tags
        self.created_at = created_at

    def __str__(self) -> str:
        return f"""---
title: {self.title}
created_at: {self.created_at.strftime("%Y-%m-%d %H:%M")}
tags: {", ".join(self.tags)}
---"""

    @classmethod
    def parse(cls, file: pathlib.Path) -> YAMLFrontmatter:
        text = file.read_text()
        match = re.match(r"^---\n((?:[a-zA-Z0-9_]+: .+\n)*)---\n", text, re.DOTALL)
        if not match:
            raise ValueError("Invalid YAML frontmatter format")

        yaml_content = match.group(1)
        parsed_data = {
            key: value.strip()
            for key, value in re.findall(r"(\w+):\s*(.+)", yaml_content)
        }

        title = parsed_data.get("title", file.stem)
        tags = [tag for tag in parsed_data.get("tags", "").split(", ") if tag]
        created_at = dt.datetime.strptime(
            parsed_data.get("created_at", ""), "%Y-%m-%d %H:%M"
        )
        return cls(title=title, tags=tags, created_at=created_at)


def init_file(path: pathlib.Path, tags: list[str], content: str) -> None:
    frontmatter = YAMLFrontmatter(title=path.stem, tags=tags)
    path.touch()
    path.write_text(f"{frontmatter}\n\n\n{content}")


@contextlib.contextmanager
def cd(root: pathlib.Path) -> Generator:
    directory = os.getcwd()
    os.chdir(root)
    try:
        yield
    finally:
        os.chdir(directory)


def fzf_open(query: str, reload_cmd: str, preview_cmd: str) -> None:
    # fmt: off
    fzf_cmd = [
        "fzf", "--disabled", "--ansi", "--multi",
        "--bind", f"start:{reload_cmd}",
        "--bind", f"change:{reload_cmd}",
        "--bind", "enter:become:if [[ $FZF_SELECT_COUNT -eq 0 ]]; then vim {1} +{2}; else vim +cw -q {+f}; fi",
        "--delimiter", ":",
        "--preview", preview_cmd,
        "--preview-window", "~4,+{2}+4/3,<80(up)",
        "--query", query,
    ]
    # fmt: on

    try:
        subprocess.run(fzf_cmd, check=True)
    except subprocess.CalledProcessError:
        error("Something went wrong with FZF!")


def fzf_select(query: str, reload_cmd: str, preview_cmd: str) -> list[pathlib.Path]:
    # fmt: off
    fzf_cmd = [
        "fzf", "--disabled", "--ansi", "--multi",
        "--bind", f"start:{reload_cmd}",
        "--bind", f"change:{reload_cmd}",
        "--preview", preview_cmd,
        "--preview-window", "~4,+{2}+4/3,<80(up)",
        "--query", query,
    ]
    # fmt: on

    try:
        result = subprocess.check_output(fzf_cmd)
    except subprocess.CalledProcessError:
        error("Something went wrong with FZF!")

    return [pathlib.Path(f) for f in result.decode("utf-8").strip().splitlines()]


# Input parsing ============================================================
def init() -> tuple[pathlib.Path, str, list[str]]:
    _check_dependencies()
    root = _get_root()
    cmd, args = _parse_cmd_and_args()
    return root, cmd, args


def _get_root() -> pathlib.Path:
    root = os.environ.get(ROOT_ENV_VAR)
    if not root:
        error("Root not set!")

    root_path = pathlib.Path(root)  # type: ignore[arg-type] # Guaranteed to be set
    if not root_path.exists():
        error(f"Root '{root_path}' does not exist!")

    if not root_path.is_dir():
        error(f"Root '{root_path}' is not a directory!")

    return root_path


def _parse_cmd_and_args() -> tuple[str, list[str]]:
    args = sys.argv[1:]
    if len(args) == 0:
        return "help", []

    return args[0], args[1:]


def _check_dependencies() -> None:
    for dep in DEPENDENCIES:
        if shutil.which(dep) is None:
            error(f"Dependency {dep} not found!")


# Main =====================================================================
if __name__ == "__main__":
    root, cmd, args = init()
    if cmd not in COMMAND_MAP:
        error(
            f"Command {cmd} not found! Use `{BLUE}oak help{RESET}` to see available commands."
        )

    fn, _ = COMMAND_MAP[cmd]
    fn(root=root, args=args)
