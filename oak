#!/usr/bin/env python3
from __future__ import annotations

import contextlib
import datetime as dt
import os
import pathlib
import shutil
import subprocess
import sys


# Constants ================================================================
ROOT_ENV_VAR = "OAK_ROOT"
DEPENDENCIES = ("fd", "rg", "fzf", "bat", "nvim")
GREEN = "\033[32m"
RED = "\033[31m"
BLUE = "\033[34m"
RESET = "\033[0m"  # Resets color to default


# Commands =================================================================
def add_cmd(root: pathlib.Path, args: list[str]) -> None:
    name = args[0] if args else f"tmp-{dt.datetime.now().strftime('%Y-%m-%d-%H-%M')}"
    tags = args[1:] if len(args) > 1 else []
    file_path = root / f"{name}.md"
    open_note(file_path, tags=tags)


def daily_cmd(root: pathlib.Path, args: list[str]) -> None:
    today = dt.datetime.now().strftime("%Y-%m-%d")
    file_path = root / f"{today}.md"
    open_note(file_path, tags=["daily"])


def delete_cmd(root: pathlib.Path, args: list[str]) -> None:
    query = args[0] if args else ""
    with cd(root):
        files = fzf_select(
            query=query,
            reload_cmd="reload:fd -e md --hidden --follow --exclude .git {q}",
            preview_cmd="bat {} --style=full --color=always",
        )
        for file in files:
            file.unlink()
            print(f"{BLUE}[DELETED]{RESET} {file.name}")


def grep_cmd(root: pathlib.Path, args: list[str]) -> None:
    query = args[0] if args else ""
    with cd(root):
        fzf_open(
            query=query,
            reload_cmd="reload:rg --column --color=always --smart-case {q} || :",
            preview_cmd="bat --style=full --color=always --highlight-line {2} {1}",
        )


def find_cmd(root: pathlib.Path, args: list[str]) -> None:
    query = args[0] if args else ""
    with cd(root):
        fzf_open(
            query=query,
            reload_cmd="reload:fd -e md --hidden --follow --exclude .git {q}",
            preview_cmd="bat {} --style=full --color=always",
        )


def list_cmd(root: pathlib.Path, args: list[str]) -> None:
    files = sorted(root.iterdir(), key=lambda f: f.stat().st_mtime, reverse=True)
    for file in files:
        if file.suffix == ".md":
            print(file.name)


def help_cmd(root: pathlib.Path, args: list[str]) -> None:
    for cmd, (_, description) in COMMAND_MAP.items():
        print(f"{GREEN}{cmd:10}{RESET} {description}")


COMMAND_MAP = {
    "add": (add_cmd, "Add a new note"),
    "daily": (daily_cmd, "Add a new daily note"),
    "delete": (delete_cmd, "Delete note(s)"),
    "grep": (grep_cmd, "Search notes by content"),
    "find": (find_cmd, "Search notes by name"),
    "list": (list_cmd, "List notes (in reverse chronological order)"),
    "help": (help_cmd, "Print this help message"),
}


# Utils ====================================================================
def error(message: str) -> None:
    print(f"{RED}[ERROR]{RESET} {message}")
    sys.exit(1)


def open_note(path: pathlib.Path, tags: list[str]) -> None:
    if not path.exists():
        _init_file(path=path, tags=tags)

    subprocess.run(["nvim", path])


def _init_file(path: pathlib.Path, tags: list[str]) -> None:
    frontmatter = f"""---
title: {path.stem}
created_at: {dt.datetime.now().strftime("%Y-%m-%d %H:%M")} 
tags: {", ".join(tags)}
---"""

    path.touch()
    path.write_text(f"{frontmatter}\n\n\n")


@contextlib.contextmanager
def cd(root: pathlib.Path):
    dir = os.getcwd()
    os.chdir(root)
    try:
        yield
    finally:
        os.chdir(dir)


def fzf_open(query: str, reload_cmd: str, preview_cmd: str) -> None:
    # fmt: off
    fzf_cmd = [
        "fzf", "--disabled", "--ansi", "--multi",
        "--bind", f"start:{reload_cmd}",
        "--bind", f"change:{reload_cmd}",
        "--bind", "enter:become:if [[ $FZF_SELECT_COUNT -eq 0 ]]; then vim {1} +{2}; else vim +cw -q {+f}; fi",
        "--delimiter", ":",
        "--preview", preview_cmd,
        "--preview-window", "~4,+{2}+4/3,<80(up)",
        "--query", query,
    ]
    # fmt: on

    try:
        subprocess.run(fzf_cmd, check=True)
    except subprocess.CalledProcessError:
        error("Something went wrong with FZF!")


def fzf_select(query: str, reload_cmd: str, preview_cmd: str) -> list[pathlib.Path]:
    # fmt: off
    fzf_cmd = [
        "fzf", "--disabled", "--ansi", "--multi",
        "--bind", f"start:{reload_cmd}",
        "--bind", f"change:{reload_cmd}",
        "--preview", preview_cmd,
        "--preview-window", "~4,+{2}+4/3,<80(up)",
        "--query", query,
    ]
    # fmt: on

    try:
        result = subprocess.check_output(fzf_cmd)
    except subprocess.CalledProcessError:
        error("Something went wrong with FZF!")

    return [pathlib.Path(f) for f in result.decode("utf-8").strip().splitlines()]


# Input parsing ============================================================
def init() -> tuple[pathlib.Path, str, list[str]]:
    _check_dependencies()
    root = _get_root()
    cmd, args = _parse_cmd_and_args()
    return root, cmd, args


def _get_root() -> pathlib.Path:
    root = os.environ.get(ROOT_ENV_VAR)
    if not root:
        error("Root not set!")

    root_path = pathlib.Path(root)
    if not root_path.exists():
        error(f"Root '{root_path}' does not exist!")

    if not root_path.is_dir():
        error(f"Root '{root_path}' is not a directory!")

    return root_path


def _parse_cmd_and_args() -> tuple[str, list[str]]:
    args = sys.argv[1:]
    if len(args) == 0:
        return "help", []

    return args[0], args[1:]


def _check_dependencies() -> None:
    for dep in DEPENDENCIES:
        if shutil.which(dep) is None:
            error(f"Dependency {dep} not found!")


# Main =====================================================================
if __name__ == "__main__":
    root, cmd, args = init()
    if cmd not in COMMAND_MAP:
        error(
            f"Command {cmd} not found! Use `{BLUE}oak help{RESET}` to see available commands."
        )

    fn, _ = COMMAND_MAP[cmd]
    fn(root=root, args=args)
